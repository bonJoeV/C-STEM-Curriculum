//If you are seeing these commments - you a viewing a concept version of the library. Production will have no comments and be minified.

//idea - distributor country restrictions
//idea - autocomplete - with manufacturer restrictions
//idea - language support

(function(){
	window.DistributorInventory = {
		//Search Overview ->
			//When instance created 'main' is run with creates everything based on 'setup'
			//Api is returned meaning the instance can interact with Api methods
			//See 'main' for breakdown of processes
		//Search objects ->
			//Setup: Argument passed in from 'user'
			//Config: General configurations for the setup
			//Options: The defaults for the construction of the data
			//Request: Holds the current response information from the PartSearchApi call
			//Fetch: Any methods that require fetching data externally or from DOM
			//Data: All methods for formatting / altering / updating data as well as formatted and unformatted(response) data
			//Build: All methods for building html
			//Render: Uses build methods to render on dom
			//Events: Premade events that get added i.e. thead sorting
			//Main: When instance of DistributorInventory made initial construction is created from options
			//Helper: General methods
			//Api: Returned from running new instance. Between 'user' and objects in DistributorInventory
		search: function(setup){
			//Config: General configurations
			//Shouldn't be changed by user
			//Accessible via some callbacks for currency / country info
			var config = {
				apiAddr: 'https://beta.api.oemsecrets.com/partsearch',
				currencies: { 
					'AUD': '&#36;', 'CAD': '&#36;', 'CHF': '&#67;&#72;&#70;', 'CNY': '&#165;', 'DKK': '&#107;&#114;', 'EUR': '&#8364;', 
					'GBP': '&#163;', 'HKD': '&#36;', 'ILS': '&#8362;', 'INR': '&#8377;', 'JPY': '&#165;', 'KRW': '&#8361;', 'NOK': '&#107;&#114;', 
					'NZD': '&#36;', 'RUB': '&#1088;&#1091;&#1073;', 'SEK': '&#107;&#114;', 'SGD': '&#36;', 'TWD': '&#78;&#84;&#36;', 'USD': '&#36;'},
				countries: { 
					'US': {currency: 'USD', name: 'United States', region: 'North America'}, 
					'VI': {currency: 'USD', name: 'Vietnam', region: 'Asia'},
					'AD': {currency: 'EUR', name: 'Andorra', region: 'Europe'},
					'AT': {currency: 'EUR', name: 'Austria', region: 'Europe'},
					'BE': {currency: 'EUR', name: 'Netherlands', region: 'Europe'},
					'EE': {currency: 'EUR', name: 'Estonia', region: 'Europe'},
					'FI': {currency: 'EUR', name: 'Finland', region: 'Europe'},
					'FR': {currency: 'EUR', name: 'France', region: 'Europe'},
					'DE': {currency: 'EUR', name: 'Germany', region: 'Europe'},
					'GR': {currency: 'EUR', name: 'Greece', region: 'Europe'},
					'AU': {currency: 'AUD', name: 'Australia', region: 'Asia'},
					'NO': {currency: 'NOK', name: 'Norway', region: 'Europe'},
					'SK': {currency: 'EUR', name: 'Slovakia', region: 'Europe'},
					'SI': {currency: 'EUR', name: 'Slovenia', region: 'Europe'},
					'ES': {currency: 'EUR', name: 'Spain', region: 'Europe'},
					'SJ': {currency: 'NOK', name: 'Svalbard and Jan Mayen', region: 'Europe'},
					'CA': {currency: 'CAD', name: 'Canada', region: 'North America'},
					'CN': {currency: 'CNY', name: 'China', region: 'Asia'},
					'HK': {currency: 'HKD', name: 'Hong Kong', region: 'Asia'},
					'NZ': {currency: 'NZD', name: 'New Zealand', region: 'Asia'},
					'DK': {currency: 'DKK', name: 'Denmark', region: 'Europe'},
					'FO': {currency: 'DKK', name: 'Faroe Islands', region: 'Europe'},
					'GL': {currency: 'DKK', name: 'Greenland', region: 'North America'},
					'IN': {currency: 'INR', name: 'India', region: 'Asia'},
					'RU': {currency: 'RUB', name: 'Russia', region: 'Europe'},
					'IM': {currency: 'GBP', name: 'Isle of Man', region: 'Europe'},
					'JE': {currency: 'GBP', name: 'Jersey', region: 'Europe'},
					'GB': {currency: 'GBP', name: 'United Kingdom', region: 'Europe'},
					'IL': {currency: 'ILS', name: 'Israel', region: 'Europe'},
					'JP': {currency: 'JPY', name: 'Japan', region: 'Asia'},
					'KR': {currency: 'KRW', name: 'South Korea', region: 'Asia'},
					'LI': {currency: 'CHF', name: 'Liechtenstein', region: 'Europe'},
					'CH': {currency: 'CHF', name: 'Switzerland', region: 'Europe'},
					'SG': {currency: 'SGD', name: 'Singapore', region: 'Asia'},
					'SE': {currency: 'SEK', name: 'Sweden', region: 'Europe'},
					'TW': {currency: 'TWD', name: 'Taiwan', region: 'Asia'},
				},
			},
			//Options: The defaults for the construction of the data
			//Each function that refers to 'options' refers to here
			//See documentation for options and impacts on data
			options = {
				key: false,
				container: setup.container,
				currency: 'default',
				country: 'default',
				search: {
					term: setup.search.term,
					exact: false
				},
				breaks: {
					standard: [1],
					custom: 1
				},
				price_sum: {
					min_moq: false
				},
				distributors: [],
				independent_distributors: false,
				manufacturers: [],
				part_numbers: [],
				part_canons: false,
				applied_filters: {},
				groups: {
					field: 'part_by_manufacturer',
					order: ['grouping', 'asc'],
					limit: -1,
				},
				items: {
					order: ['distributor_name', 'asc'], 
					manual_order: [],
					limit: -1,  
					limit_expander: true,
					limit_collapser: true,
				},
				results: {
					result_group: 'part_by_distributor',
					expand_on_interaction: true,
					order: ['quantity_in_stock', 'desc'],
					limit: 1,
				},
				//Render: Gets completely overwritten
				//When calling anything from 'render' need to check it exists (use helper.keyExists)
				render: {
					structure: 'table',
					group: {
						columns: [
							{field: 'distributor_name', sort: true},
							{field: 'quantity_in_stock', sort: true},
							{field: 'buy_now_url', sort: false, build: function(data){return '<a href="'+data+'">Buy Now</a>'}}
						],
					},
				},
				callbacks: {
					render: function(){},
					prerender: function(){},
				}
			},
			//Request: Holds the current response information from the API JSON call
			request = {
				//Data from the response is held here - populated from fetch.data
				response: {},
				//If the response is successful the callback from this function will run
				//Passes the response text as an argument
				success: function(callback){
					request.response.onreadystatechange = function(){
						if(request.response.readyState == 4 && request.response.status == 200){
							callback(JSON.parse(request.response.responseText));
						}
					};
				},
			},
			//Fetch: Any functions that require fetching data externally / from DOM / other areas
			fetch = {
				//Data populates the request.response object with response info
				data: function(){
					if(fetch.key()){
						var apiCall = new XMLHttpRequest();
						apiCall.open('POST', config.apiAddr , true);
						apiCall.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
						apiCall.send('apiKey='+fetch.key()+ fetch.currencies() + fetch.country() + '&searchTerm=' + options.search.term);
						request.response = apiCall;
					}
				},
				//Gets key from library script
				key: function(){
					var key = options.key;
					if(!options.key){
						var keys = document.querySelectorAll('script[data-di-key]');
		    			key = keys.length != 0 ? keys[0].dataset.diKey : options.key;
		    		}
					return key;
				},
				//Gets node from DOM based on selector string
				instanceNode: function(){
					return document.querySelector(options.container);
				},
				//Overwrites 'options' with 'setup' where specified
				//If not specified in 'setup' defaults from 'options' are used
				//Don't refer to 'setup' object unless it is a required i.e. setup.container
				setup: function(){
					//As the user doesn't have to enter a value it's not guaranteed that the object exists
					/*The helper.replaceOptions function passes the 'setup' object that must exist then 
					takes a string of its location which it uses to check each object nest exists
					i.e. if setup.results is undefined it won't check setup.results.result_group as it
					will result in a reference error. The final field is to build the object up to its 
					parent and use the key as a setter. If only try / catch was supported in IE*/
					var check = [
						{keyString: 'key',location: options,key: 'key'},
						{keyString: 'search.exact',location: options.search,key: 'exact'},
						{keyString: 'distributors',location: options,key: 'distributors'},
						{keyString: 'independent_distributors',location: options,key: 'independent_distributors'},
						{keyString: 'manufacturers',location: options,key: 'manufacturers'},
						{keyString: 'applied_filters',location: options,key: 'applied_filters'},
						{keyString: 'part_numbers',location: options,key: 'part_numbers'},
						{keyString: 'groups.field',location: options.groups,key: 'field'},
						{keyString: 'groups.order',location: options.groups,key: 'order'},
						{keyString: 'groups.limit',location: options.groups.limit,key: 'amount'},
						{keyString: 'items.order',location: options.items,key: 'order'},
						{keyString: 'items.limit',location: options.items,key: 'limit'},
						{keyString: 'items.manual_order',location: options.items,key: 'manual_order'},
						{keyString: 'items.limit_expander',location: options.items,key: 'limit_expander'},
						{keyString: 'items.limit_collapser',location: options.items,key: 'limit_collapser'},
						{keyString: 'results.order',location: options.results,key: 'order'},
						{keyString: 'results.expand_on_interaction',location: options.results,key: 'expand_on_interaction'},
						{keyString: 'results.result_group',location: options.results,key: 'result_group'},
						{keyString: 'results.limit',location: options.results,key: 'limit'},
						{keyString: 'callbacks.render',location: options.callbacks,key: 'render'},
						{keyString: 'callbacks.prerender',location: options.callbacks,key: 'prerender'},
						{keyString: 'render',location: options,key: 'render'},
						{keyString: 'currency',location: options,key: 'currency'},
						{keyString: 'country',location: options,key: 'country'},
						{keyString: 'breaks.standard',location: options.breaks,key: 'standard'},
						{keyString: 'breaks.custom',location: options.breaks,key: 'custom'},
						{keyString: 'price_sum.min_moq',location: options.price_sum,key: 'min_moq'},
						{keyString: 'part_canons',location: options,key: 'part_canons'},
					];
					check.forEach(function(item){
						helper.replaceOptions(setup, item.keyString, item.location, item.key);
					});
				},
				//Builds the strings for the POST required
				//to do - move this to a place that makes more sense?
				currencies: function(){
					var string = '';
					for(var currency in config.currencies){
						string += '&currency[]=' + currency;
					}
					return string;
				},
				//Builds the strings for the POST required
				//to do - move this to a place that makes more sense?
				country: function(){
					var string = '';
					if(options.country !== 'default'){
						string += '&countryCode=' + options.country;
					}
					return string;
				},
				//Replaces the country information based on the call data.
				//i.e. If the 'default' country request is from GB will set as GB and currency as GBP.
				userInfo: function(){
					if(options.country == 'default'){
						if(typeof(config.countries[data.formatted.country_iso]) !== 'undefined'){
							options.country = data.formatted.country_iso;
						} else {
							options.country = 'US';
						}
					}
					if(options.currency == 'default'){
						options.currency = config.countries[options.country].currency;
					}
				},	
			},
			//Data: All methods for formatting / altering / updating data as well as formatted and unformatted data
			data = {
				//Data from request.response.stock
				unformatted: [],
				//Data that will change based on the functions that have been run on it.
				formatted: {},
				//Removes any data that needs to be permanently removed as per options
				//Blanks arrays mean no removals
				//Also removes results that don't begin with the term - as PartSearchApi doesn't support
				exclude: {
					setup: function(){
						var setupfilters = [];
						data.unformatted.forEach(function(result){
							var isAllowedMfg = options.manufacturers.length > 0 ? options.manufacturers.indexOf(result.manufacturer) !== -1 : true,
								isAuthDistr = !options.independent_distributors ? result.distributor_authorisation_status == 'authorised' : true,
								isAllowedDistr = options.distributors.length > 0 ? options.distributors.indexOf(parseInt(result.distributor.distributor_common_id)) !== -1 : true,
								isAllowedPart = options.part_numbers.length > 0 ? options.part_numbers.indexOf(result.part_number.toUpperCase()) !== -1 : true,
								isPartExact = options.search.exact ? helper.replaceNonAlpha(options.search.term.toUpperCase()) == result.part_number.toUpperCase() : true,
								startsWithTerm = result.part_number.toUpperCase().startsWith(helper.replaceNonAlpha(options.search.term.toUpperCase()));
							if(isAuthDistr && isAllowedMfg && isAllowedDistr && isAllowedPart && isPartExact && startsWithTerm){
								setupfilters.push(result);
							}
						});
						data.unformatted = setupfilters;
					}
				},
				//Any methods that change the structures of the data
				format: {
					//Use data.formatted to create the new object structure
					//Any additions to data outside of groups[] should created here and updated where appropriate
					initialise: function(response){
						var obj = {
							country_iso: response.country_code,
							summary: {filtered: 0,results: 0,},
							uniques: {manufacturer: [],distributor_common_name: [],part_by_manufacturer: [],part_number: [], no_group: []},
							settings: {
								grouping:  {},
								order: {},
								filters: {
									//must use same name as in result
									manufacturer: [],
									part_by_manufacturer: [],
									part_number: [],
									distributor_name: [],
									distributor_common_name: [],
									distributor_authorisation_status: [],
									distributor_country: [],
									distributor_region: [],
									distributor_common_id: [],
									quantity_in_stock: [],
									packaging: [],
									eccncode: [],
									lead_time_weeks: [],
									min_break: [],
								},

							},
							groups: [],
							term: response.search_term,
							canons: {},
						}					
						data.formatted = obj;
						data.unformatted = response.stock;
					},
					appliedFilters: function(){
						if(options.applied_filters.length != 0){
							for(var filter in options.applied_filters){
								options.applied_filters[filter].forEach(function(filterItem){
									data.formatted.settings.filters[filter].push(filterItem);
								});
							}
						}
					},
					//Any column data is removed from object nests and calculates which pricing to use
					//Pre is done before format in construct
					//Post can be done at any point
					unpack: {
						pre: function(){
							data.unformatted.forEach(function(result){
								result.part_number = result.part_number.toUpperCase();
								result.distributor_name = result.distributor.distributor_name;
								result.distributor_logo = result.distributor.distributor_logo;
								result.distributor_region = result.distributor.distributor_region;
								result.distributor_country = result.distributor.distributor_country;
								result.distributor_common_name = result.distributor.distributor_common_name;
								result.distributor_common_id = parseInt(result.distributor.distributor_common_id);
								result.distributor_id = parseInt(result.distributor.distributor_id);
								result.part_by_manufacturer = result.part_number + ' ' + result.manufacturer;
								result.part_by_distributor = result.part_number + ' ' + result.distributor.distributor_name;
								result.rohs_status = result.compliance.rohs;
								result.no_group = '';
								data.format.unpack.pricing(result);
							});
						},
						post: function(index, qty){
							if(typeof(index) == 'undefined'){
								data.formatted.groups.forEach(function(groupObj){
									groupObj.settings.quantity = parseInt(options.breaks.custom);
									groupObj.items.forEach(function(itemObj){
										itemObj.results.forEach(function(result){
											data.format.unpack.pricing(result, groupObj);
										});
									})
								})
							} else {
								data.formatted.groups[index].settings.quantity = parseInt(qty);
								data.formatted.groups[index].items.forEach(function(itemObj){
									itemObj.results.forEach(function(result){
										data.format.unpack.pricing(result, data.formatted.groups[index]);
									});
								});
							}
						},
						pricing: function(result, groupObj){
							var quantity = typeof(groupObj) == 'undefined' ? options.breaks.custom : groupObj.settings.quantity;
							result.min_break_price = parseFloat(result.prices[options.currency][0].unit_price);
							result.min_break = parseFloat(result.prices[options.currency][0].unit_break);
							result.price_at_custom = parseFloat(helper.getBreakPrice(quantity, result.prices[options.currency]));
							options.breaks.standard.forEach(function(breakVal){
								result['price_at_' + breakVal] = parseFloat(helper.getBreakPrice(breakVal, result.prices[options.currency]));
							});
							if(!options.price_sum.min_moq){
								result.price_sum = parseFloat(result.price_at_custom * quantity);
							} else {
								if(result.min_break > quantity){
									result.price_sum = parseFloat(result.min_break_price * result.min_break);
								} else {
									result.price_sum = parseFloat(result.price_at_custom * quantity);
								}
							}
						}
					},
					//Data is placed into a group format based on 'options' preferences.
					//Fairly intensive process of lots of groups
					//For each 'unique' grouping i.e. part_by_manufacturer checks if data from unformatted data matches group
					//Structure for data is instance{} => groups[] => group{} => items[] => item{} => results[]
					//Groups is made up of objects containing summary, groups
					//At this stage each item has 1 result in results[] until result_group method (if run)
					//improvement - proccesses could be more optimized using grouping name as index?
					group: function(field){
						var groups = [];
						data.formatted.uniques[field].forEach(function(groupName, groupKey){
							var groupObj = {}
							groupObj.items = [];
							groupObj.summary = data.group.summary.create(groupName);
							groupObj.settings = data.group.settings.create(groupKey);
							data.unformatted.forEach(function(result){
								if(result[field] == groupName){
									var resultsObj = {};
									resultsObj.results = [result];
									resultsObj.summary = {unique: result.part_by_distributor,}
									resultsObj.settings = {filter: {results: 0,filtered: 0,}, limit: false, result_limit: options.results.limit, order: {field: options.items.order[0], direction:  options.items.order[1]}}
									groupObj.items.push(resultsObj);
									data.group.summary.update(groupObj, result);
								}
							});
							data.group.summary.post(groupObj, groupKey);
							groups.push(groupObj);
						});
						data.formatted.groups = groups;
						data.formatted.settings.grouping.field = field;
					},
				},
				/* --- Methods that alter the data should be placed in to the object that its affecting --- */
				//Methods for altering instance information but not format
				instance: {
					uniques: {
						initial: function(){
							data.unformatted.forEach(function(result){
								for (var uniquesKey in data.formatted.uniques){
									if(data.formatted.uniques[uniquesKey].indexOf(result[uniquesKey]) == -1 ){
										data.formatted.uniques[uniquesKey].push(result[uniquesKey]);
									}
								}
							});
						},
						rescan: function(){
							var rescannedUniques = {
								manufacturer: [],
								distributor_common_name: [],
								part_by_manufacturer: [],
								part_number: [],
								no_group: [],
							};
							data.formatted.groups.forEach(function(groupObj, groupKey){
								if((options.groups.limit - 1) >= groupKey || options.groups.limit == -1){
									groupObj.items.forEach(function(itemObj){
										itemObj.results.forEach(function(result){
											for (var uniquesKey in rescannedUniques){
												if(rescannedUniques[uniquesKey].indexOf(result[uniquesKey]) == -1 ){
													rescannedUniques[uniquesKey].push(result[uniquesKey]);
												}
											}
										});
									});	
								}
							});
							data.formatted.uniques = rescannedUniques;
						}
					},
					filter: function(){
						data.formatted.summary.filtered = 0;
						data.formatted.summary.results = 0;
						data.formatted.groups.forEach(function(groupObj){
							groupObj.settings.filter.groups = 0;
							groupObj.settings.filter.filtered = 0;
							groupObj.items.forEach(function(itemObj){
								itemObj.settings.filter.results = 0;
								itemObj.settings.filter.filtered = 0;
								itemObj.results.forEach(function(result){
									var filters = data.formatted.settings.filters;
									var filterFlags = [];
									for (var filter in filters){
										filterFlags.push(filters[filter].indexOf(result[filter]) == -1);
									}
									//if any filter flags aren't true
									var dontFilter = filterFlags.every(function(val){return val})
									itemObj.settings.filter.results ++;
									if(dontFilter){
										result.filter_flag = false;
									} else {
										result.filter_flag = true;
										itemObj.settings.filter.filtered ++;
									}
								});
								if(itemObj.settings.filter.results == itemObj.settings.filter.filtered){
									groupObj.settings.filter.filtered ++;
								}
								groupObj.settings.filter.groups ++;
							});
							data.formatted.summary.results ++;
							if(groupObj.settings.filter.groups == groupObj.settings.filter.filtered){
								data.formatted.summary.filtered ++;
							}
						});
					},
					canons: {
						add: function(){
							data.formatted.uniques.part_by_manufacturer.forEach(function(unique){
								data.formatted.canons[unique] = {
									part_number: {value: '',source: '',},
									manufacturer: {value: '',source: '',},
									datasheet: {value: '',source: '',},
									part_image: {value: '',source: '',},
									description: {value: '',source: '',},
									rohs: {value: '',source: '',},
								};
							});
							data.formatted.groups.forEach(function(groupObj){
								groupObj.items.forEach(function(itemObj){
									itemObj.results.forEach(function(result, resultKey){
										var canonPart = data.formatted.canons[result.part_by_manufacturer];
										data.instance.canons.fetch.partNumber(result, resultKey, canonPart);
										data.instance.canons.fetch.manufacturer(result, resultKey, canonPart);
										data.instance.canons.fetch.datasheet(result, resultKey, canonPart);
										data.instance.canons.fetch.partImage(result, resultKey, canonPart);
										data.instance.canons.fetch.description(result, resultKey, canonPart);
										data.instance.canons.fetch.rohs(result, resultKey, canonPart);
									});
								})
							});
						},
						fetch: {
							partNumber: function(result, resultKey, canonPart){
								if(canonPart.part_number.value == ''){
									canonPart.part_number.value = result.source_part_number;
									canonPart.part_number.source = result.distributor_name;
								}
							},
							manufacturer: function(result, resultKey, canonPart){
								if(canonPart.manufacturer.value == ''){
									canonPart.manufacturer.value = result.manufacturer;
									canonPart.manufacturer.source = result.distributor_name;
								}
							},
							datasheet: function(result, resultKey, canonPart){
								if(canonPart.datasheet.value == ''){
									canonPart.datasheet.value = result.datasheet_url;
									canonPart.datasheet.source = result.distributor_name;
								}
							},
							partImage: function(result, resultKey, canonPart){
								if(canonPart.part_image.value == ''){
									canonPart.part_image.value = result.image_url;
									canonPart.part_image.source = result.distributor_name;
								}
							},
							description: function(result, resultKey, canonPart){
								var isLonger = canonPart.description.value.length < result.description.length;
								var containsNoColons = result.description.indexOf(';') == -1;
								if(containsNoColons && isLonger){
									canonPart.description.value = result.description;
									canonPart.description.source = result.distributor_name;
								}
							},
							rohs: function(result, resultKey, canonPart){
								if(canonPart.rohs.value == ''){
									canonPart.rohs.value = result.compliance.rohs;
									canonPart.rohs.source = result.distributor_name;
								}
							},
						}
					}
				},
				//Methods for altering group information but not format
				//Group methods should take an index of the group as a paramter
				group: {
					//Methods for creating and updating summary information
					//Post runs at the end of the loop
					summary: {
						create: function(groupName){
							var summary = {
								grouping: groupName,
								total_stock: 0,
								lowest_min_break: -1,
								lowest_min_break_price: -1,
								lowest_current_price: -1,
								lowest_total_price: -1,
								results: 0,
								items: 0,
								breaks: [],
								unique_breaks: [],
								recurring_breaks: [],
							};
							return summary;
						},
						update: function(groupObj, result){
							var lowestMinBreakPrice = groupObj.summary.lowest_min_break_price;
							if(lowestMinBreakPrice == -1 && parseFloat(result.min_break_price) != 0){
								lowestMinBreakPrice = parseFloat(result.min_break_price);
							} else if(lowestMinBreakPrice > parseFloat(result.min_break_price) && parseFloat(result.min_break_price) != 0){
								lowestMinBreakPrice = parseFloat(result.min_break_price);
							}
							var lowestTotalPrice =  groupObj.summary.lowest_total_price;
							if(lowestTotalPrice == -1 && parseFloat(result.price_sum) != 0){
								lowestTotalPrice = parseFloat(result.price_sum);
							} else if(lowestTotalPrice > parseFloat(result.price_sum) && parseFloat(result.price_sum) != 0){
								lowestTotalPrice = parseFloat(result.price_sum);
							}
							var lowestCurrentPrice =  groupObj.summary.lowest_current_price;
							if(lowestCurrentPrice == -1 && parseFloat(result.price_at_custom) != 0){
								lowestCurrentPrice = parseFloat(result.price_at_custom);
							} else if(lowestCurrentPrice > parseFloat(result.price_at_custom) && parseFloat(result.price_at_custom) != 0){
								lowestCurrentPrice = parseFloat(result.price_at_custom);
							}
							result.prices[options.currency].forEach(function(price){
								groupObj.summary.breaks.push(price.unit_break);
								if(groupObj.summary.unique_breaks.indexOf(price.unit_break) == -1){
									groupObj.summary.unique_breaks.push(price.unit_break);
								}
							});
							groupObj.summary.total_stock = parseInt(result.quantity_in_stock) + parseInt(groupObj.summary.total_stock);
							groupObj.summary.lowest_min_break_price = lowestMinBreakPrice;
							groupObj.summary.lowest_total_price = lowestTotalPrice;
							groupObj.summary.lowest_current_price = lowestCurrentPrice;
							groupObj.summary.results = groupObj.summary.results + 1;
						},
						post: function(groupObj, groupKey){
							groupObj.summary.breaks.sort(function(a, b){
								return helper.sorter('asc', a, b);
							});
							groupObj.summary.unique_breaks.sort(function(a, b){
								return helper.sorter('asc', a, b);
							});

							var counts = {};
							groupObj.summary.breaks.forEach(function(breakVal){
								if(typeof(counts[breakVal]) == 'undefined'){
									counts[breakVal] = 1;
								} else {
									counts[breakVal] ++;
								}
							});
							var countsArr = [];
							for(var count in counts){
								var countObj = {};
								countObj[count] = counts[count];
								countsArr.push(countObj);
							}
							countsArr.sort(function(a, b){
								a = a[Object.keys(a)[0]];
								b = b[Object.keys(b)[0]]
								return helper.sorter('desc', a, b);
							});
							groupObj.summary.recurring_breaks = countsArr;
							groupObj.summary.items = groupObj.items.length;
							if(groupObj.summary.unique_breaks.length > 0){
								groupObj.summary.lowest_min_break = groupObj.summary.unique_breaks[0];
							}
						},
						reprocess: function(){
							data.formatted.groups.forEach(function(groupObj, groupKey){
								groupObj.summary.total_stock = 0;
								groupObj.summary.lowest_min_break_price = -1;
								groupObj.summary.lowest_current_price = -1;
								groupObj.summary.lowest_total_price = -1;
								groupObj.summary.results = 0;
								groupObj.summary.items = 0;
								groupObj.summary.breaks = [];
								groupObj.summary.unique_breaks = [];
								groupObj.summary.recurring_breaks = [];
								groupObj.items.forEach(function(itemObj, itemKey){
									itemObj.results.forEach(function(result){
										data.group.summary.update(groupObj, result);
									})
								})
								data.group.summary.post(groupObj, groupKey);
							})
						}
					},
					//
					settings: {
						create: function(groupKey){
							var settings = {
								limit: false,
								items_limit: options.items.limit,
								filter: {groups: 0,filtered: 0},
								order: {},
								quantity: 1,
							};
							return settings;
						}
					},
					//Sorting the order of groups
					//Don't set options value from here - do it from API
					sort: function(order){
						var field = order[0], direction = order[1];
						data.formatted.groups.sort(function(a, b){
							a = helper.standardise(a.summary[field]);
							b = helper.standardise(b.summary[field]);
							return helper.sorter(direction, a, b);
						});
						data.formatted.settings.order.field = field;
						data.formatted.settings.order.direction = direction;				
					},
					//Sets which groups to limit (doesn't remove just marks flag under settings)
					//to do - find why setting value to -1 doesn't work when using API
					limit: function(groupIndex){
						if(typeof(groupIndex) == 'undefined'){
							data.formatted.groups.forEach(function(groupObj, groupKey){
								groupObj.settings.limit = false;
								if(options.groups.limit > 0){
									if(groupKey + 1 > options.groups.limit){
										groupObj.settings.limit = true;
									}
								} else {
									groupObj.settings.limit = false;
								}
							})
						} else {
							data.formatted.groups[groupIndex].settings.limit = false;
						}
					},
				},
				//Methods for altering item information but not format
				//Item methods should take an index of the group as a paramter
				/*If the groupIndex parameter exists the function should only run on that parameter, if it doesn't exist
				it should affect all groups*/
				items: {
					//If groupIndex exists only affects that group
					sort: function(order, groupIndex){
						if(typeof(groupIndex) == 'undefined'){
							var field = order[0], direction = order[1];
							data.formatted.groups.forEach(function(groups, key){
								groups.items.sort(function(a, b){
									a = helper.standardise(a.results[0][field]);
									b = helper.standardise(b.results[0][field]);
									return helper.sorter(direction, a, b);
								});	
								data.formatted.groups[key].settings.order.field = field;
								data.formatted.groups[key].settings.order.direction = direction;
							});
						} else {
							var field = order[0], direction = order[1];
							data.formatted.groups[groupIndex].items.sort(function(a, b){
								a = helper.standardise(a.results[0][field]);
								b = helper.standardise(b.results[0][field]);
								return helper.sorter(direction, a, b);
							});	
							data.formatted.groups[groupIndex].settings.order.field = field;
							data.formatted.groups[groupIndex].settings.order.direction = direction;
						}
					},
					//If any distributor id's are present in options.items.manual_order pushes them to the beginning (in order as per array)
					manualOrder: function(){
						options.items.manual_order.reverse();
						if(options.items.manual_order.length !== 0){
							data.formatted.groups.forEach(function(groupObj){
								options.items.manual_order.forEach(function(distributorId){
									groupObj.items.forEach(function(itemObj, itemIndex){
										if(itemObj.results[0].distributor_common_id == distributorId){
											groupObj.items.splice(itemIndex, 1);
											groupObj.items.unshift(itemObj);
										}
									});
								});
							});
						}
					},
					//If groupIndex exists only affects that group
					limit: function(groupIndex, limit){
						//If group index doesn't exist then sets limit to global settings for each group
						if(typeof(groupIndex) === 'undefined'){
							data.formatted.groups.forEach(function(groupObj, groupKey){
								groupObj.settings.items_limit = parseInt(options.items.limit);
							});
						//If group index exists sets limit to passed in integer (limit)
						} else {
							data.formatted.groups[groupIndex].settings.items_limit = limit;
						}
					},
				},
				//Methods for altering results information but not format
				results: {
					sort: function(order){
						var field = order[0],
							direction = order[1];
						data.formatted.groups.forEach(function(groupObj){
							groupObj.items.forEach(function(resultsObj){
								resultsObj.results.sort(function(a, b){
									a = helper.standardise(a[field]);
									b = helper.standardise(b[field]);
									return helper.sorter(direction, a, b);
								});
							});
						});
					},
					//(Un)resultGroup methods (un)groups part number and distributor name in a group together
					//If index is passed in will only run for that group index
					resultGroup: function(index){
						if(typeof(index) == 'undefined'){
							data.formatted.groups.forEach(function(groupObj, groupKey){
								var newItems = {};
								groupObj.items.forEach(function(itemObj){
									itemObj.results.forEach(function(resultsObj){
										if(!newItems.hasOwnProperty(resultsObj[options.results.result_group])){
											newItems[resultsObj[options.results.result_group]] = {}
											newItems[resultsObj[options.results.result_group]].settings = itemObj.settings;
											newItems[resultsObj[options.results.result_group]].summary = itemObj.summary;
											newItems[resultsObj[options.results.result_group]].results = [];
										}
									});
								});
								groupObj.items.forEach(function(itemObj){		
									for(var item in newItems){
										if(itemObj.results[0][options.results.result_group] == item){
											newItems[item].results.push(itemObj.results[0]);
										}
									}
								});
								groupObj.items = [];
								for(var item in newItems){
									groupObj.items.push(newItems[item]);
								}
								groupObj.summary.items = groupObj.items.length
							});
						} else {
							var newItems = {};
							data.formatted.groups[index].items.forEach(function(itemObj){
								itemObj.results.forEach(function(resultsObj){
									if(!newItems.hasOwnProperty(resultsObj[options.results.result_group])){
										newItems[resultsObj[options.results.result_group]] = {}
										newItems[resultsObj[options.results.result_group]].settings = itemObj.settings;
										newItems[resultsObj[options.results.result_group]].summary = itemObj.summary;
										newItems[resultsObj[options.results.result_group]].results = [];
									}
								});
							});
							data.formatted.groups[index].items.forEach(function(itemObj){		
								for(var item in newItems){
									if(itemObj.results[0][options.results.result_group] == item){
										newItems[item].results.push(itemObj.results[0]);
									}
								}
							});
							data.formatted.groups[index].items = [];
							for(var item in newItems){
								data.formatted.groups[index].items.push(newItems[item]);
							}
							data.formatted.groups[index].summary.items = data.formatted.groups[index].items.length;
						}				
					},
					resultUngroup: function(index){
						if(typeof(index) == 'undefined'){
							data.formatted.groups.forEach(function(groupObj){
								var newItems = [];
								groupObj.items.forEach(function(itemObj){
									itemObj.results.forEach(function(result){
										var newObj = {};
										newObj.summary = itemObj.summary;
										newObj.settings = itemObj.settings;
										newObj.results = [result];
										newItems.push(newObj)
									});
								});
								groupObj.items = newItems;
								groupObj.summary.items = groupObj.items.length
							});
						} else {
							var newItems = [];
							data.formatted.groups[index].items.forEach(function(itemObj){
								itemObj.results.forEach(function(result){
									var newObj = {};
									newObj.summary = itemObj.summary;
									newObj.settings = itemObj.settings;
									newObj.results = [result];
									newItems.push(newObj);
								});
							});
							data.formatted.groups[index].items = newItems;
							data.formatted.groups[index].summary.items = data.formatted.groups[index].items.length;
						}
					},
					limit: function(groupIndex, itemIndex, limit){
						//If group index and item index doesn't exist then sets limit to global settings for each group and item
						if(typeof(groupIndex) === 'undefined' && typeof(itemIndex) === 'undefined'){
							data.formatted.groups.forEach(function(groupObj, groupKey){
								groupObj.items.forEach(function(itemObj, itemkey){
									itemObj.settings.result_limit = parseInt(options.result.limit);
								})
							});
						//If group index and item index exists sets limit to passed in integer (limit)
						} else {
							data.formatted.groups[groupIndex].items[itemIndex].settings.result_limit = limit;
						}
					},
				},
			},
			//Build: Methods for building HTML
			//Logic should be restricted to whether something exists / whether true or false
			//The values passed to user callbacks should be relative to where its being called
			build = {
				//No data exists here other than options
				reloading: function(){
					var reloading = '';
					var classAttr = helper.getClass(options, 'render.reloading.class', setup, {});
					if(helper.keyExists(options, 'render.reloading.build')){
						reloading += '<div class="di">';
						reloading += '<div '+ classAttr +'>';
						reloading += options.render.reloading.build(options);
						reloading += '</div>';
						reloading += '</div>';
					} else {
						reloading += '<div class="di">';
						reloading += '<div '+ classAttr +'>Reloading distributor results for ' + options.search.term + '</div>';
						reloading += '</div>';
					}
					return reloading;
				},
				//No data exists here other than options
				loading: function(){
					var loading = '';
					var classAttr = helper.getClass(options, 'render.loading.class', setup, {});
					if(helper.keyExists(options, 'render.loading.build')){
						loading += '<div class="di">';
						loading += '<div '+ classAttr +'>';
						loading += options.render.loading.build(options);
						loading += '</div>'
						loading += '</div>';
					} else {
						loading += '<div class="di">';
						loading += '<div '+ classAttr +'>Loading distributor results for ' + options.search.term + '</div>';
						loading += '</div>';
					}
					return loading;
				},
				//Should only be used once data is generated
				//Body is the controller of the HTML build (lots of simple logic)
				//to do - think about making neater
				body: function(){
					var body = '';
					var scopedData = {options: options, config: config};
					var classAttr = helper.getClass(options, 'render.body.class', data.formatted, scopedData);
					//If the body build function exists (self build process)
					if(helper.keyExists(options, 'render.body.build')){
						if(groupObj.settings.filter.groups !== groupObj.settings.filter.filtered){
							body +=	'<div class="di">';
							body +=	'<div ' + classAttr + '>';
							body += options.render.body.build(data.formatted, scopedData);
							body += '</div>';
							body += '</div>';
						}
					//If the body build function DOESN'T exist (normal process)
					} else {
						var scopedData = {options: options, config: config};
						//If there IS data to display
						if(data.formatted.groups.length !== 0){
							//If the data HASN'T been completely filtered out
							if(data.formatted.summary.filtered !== data.formatted.summary.results){
								var groupCounter = 0;
								body +=	'<div class="di">';
								body +=	'<div ' + helper.getClass(options, 'render.body.class') + '>';
								body += build.header();
								data.formatted.groups.forEach(function(groupObj, groupKey){
									var scopedData = {group_key: groupKey, options: options, config: config};
									var groupAttrs = helper.getAttrs(options, 'render.group.section.attrs', groupObj, scopedData);
									var classAttr = helper.getClass(options, 'render.group.section.class', groupObj, scopedData);
									if(groupObj.settings.filter.groups !== groupObj.settings.filter.filtered){
										body += '<section ' + classAttr + ' ' + groupAttrs + ' data-di-group-index="'+groupKey+'">';
											if(!groupObj.settings.limit){
												body += build.group.section(groupObj, groupKey);
												groupCounter ++;
											} else {
												if(helper.keyExists(options, 'render.group.content.limited_group.build')){
													body += options.render.group.content.limited_group.build(groupObj, scopedData);
												}
											}
										body += '</section>';
									} else {
										//Makes sense to not render anything but option is there
										if(helper.keyExists(options, 'render.group.filtered.build')){
											body += '<section ' + classAttr + ' ' + groupAttrs + ' data-di-group-index="'+groupKey+'">';
											if(!groupObj.settings.limit){
												body += options.render.group.filtered.build(groupObj, scopedData);
											}
											body += '</section>';
											groupCounter ++;
										//If self build DOESN'T exists for groups (purposely empty)
										} else {
											body += '<section ' + classAttr + ' ' + groupAttrs + ' data-di-group-index="'+groupKey+'">';
											body += '</section>';
											groupCounter ++;
										}
									}
								});
								body += build.footer();
								body += '</div>';
								body += '</div>';
							//If the data HAS been completely filtered out
							} else {
								var classAttr = helper.getClass(options, 'render.filtered.class', data.formatted, scopedData);
								//If the self build of filtered results DOES exist
								if(helper.keyExists(options, 'render.filtered.build')){
									body += '<div class="'+classAttr+'">';
									body += options.render.filtered.build(data.formatted, scopedData);
									body += '</div>';
								//If the self build of filtered results DOESN'T exist
								} else {
									body += '<div class="'+classAttr+'">No results for search</div>';
								}
							}
						//If there IS NO data to display
						} else {
							var classAttr = helper.getClass(options, 'render.failed.class', data.formatted, scopedData);
							//If the self build of no results DOES exist
							if(helper.keyExists(options, 'render.failed.build')){
								body += '<div '+ classAttr + '>';
								body += options.render.failed.build(data.formatted, scopedData);
								body += '</div>';
							//If the self build of no result DOESN'T exist
							} else {
								body += '<div '+ classAttr + '>No results for ' + data.formatted.term + '</div>'
							}
						}
					}
					return body;
				},
				header: function(){
					var header = '';
					var scopedData = {options: options, config: config};
					if(helper.keyExists(options, 'render.header.build')){
						header += '<div '+ helper.getClass(options, 'render.header.class', data.formatted, scopedData) +'>';
						header += options.render.header.build(data.formatted, scopedData);
						header += '</div>';
					} else {
						header += 
						'<div '+ helper.getClass(options, 'render.header.class') +'></div>';
					}
					return header;
				},
				group: {
					section: function(groupObj, groupKey){
						var section = '';
						var scopedData = {data: data.formatted, group_key: groupKey, options: options, config: config};
						var classAttr = helper.getClass(options, 'render.group.container.class', groupObj, scopedData);
						section += '<div '+classAttr+'>';
						section += build.group.header(groupObj, groupKey);
						section += '<div data-di-table-index="'+groupKey+'">';
						section += build.group.table(groupObj, groupKey);
						section += '</div>';
						section += build.group.footer(groupObj, groupKey);
						section += '</div>';
						return section;
					},
					header: function(groupObj, groupKey){
						var header = '';
						var scopedData = {data: data.formatted, group_key: groupKey, options: options, config: config};
						var classAttr = helper.getClass(options, 'render.group.header.class', groupObj, scopedData);
						if(helper.keyExists(options, 'render.group.header.build')){
							header += '<div ' + classAttr + '>';
							header += options.render.group.header.build(groupObj, scopedData);
							header += '</div>';
						} else {
							header += 
							'<div ' + classAttr + '>'+
								'<h3>' + groupObj.summary.grouping + '</h3>'+
							'</div>';
						}
						return header;
					},
					table: function(groupObj, groupKey){
						var table = '';
						var scopedData = {data: data.formatted, group_key: groupKey, options: options, config: config}
						var tableClassAttr = helper.getClass(options, 'render.group.table.table.class', groupObj, scopedData);
						var tbodyClassAttr = helper.getClass(options, 'render.group.table.tbody.class', groupObj, scopedData);
						var theadClassAttr = helper.getClass(options, 'render.group.table.thead.class', groupObj, scopedData);
						var tfootClassAttr = helper.getClass(options, 'render.group.table.tfoot.class', groupObj, scopedData);
						var tableTag = helper.getStructureTag('table');
						var tbody = helper.getStructureTag('tbody');
						var thead = helper.getStructureTag('thead');
						var tfoot = helper.getStructureTag('tfoot');
						if(helper.keyExists(options, 'render.group.table.table.build')){
							table += '<'+table+' ' + tableclassAttr +' data-di-structure="table">';
							table += options.render.group.table.table.build(groupObj, scopedData);
							table += '</'+table+'>';
						} else {
							table += '<'+tableTag+' ' +tableClassAttr+' data-di-structure="table">';
							if(helper.keyExists(options, 'render.group.table.thead.build')){
								table += '<'+thead+' ' +theadClassAttr+' data-di-structure="thead">';
								table += options.render.group.table.thead.build(groupObj, scopedData);
								table += '</'+thead+'>';
							} else {
								table += '<'+thead+' ' +theadClassAttr+' data-di-structure="thead">';
								table += build.group.rows.thead.prehead(groupObj, groupKey);
								table += build.group.rows.thead.column(groupObj, groupKey);
								table += '</'+thead+'>';
							}
							if(helper.keyExists(options, 'render.group.table.tbody.build')){
								table += '<'+tbody+' '+tbodyClassAttr+' data-di-structure="tbody">';
								table += options.render.group.table.tbody.build(groupObj, scopedData);
								table += '</'+tbody+'>';
							} else {
								table += '<'+tbody+' '+tbodyClassAttr+' data-di-structure="tbody">';
								table += build.group.rows.tbody(groupObj, groupKey);
								table += '</'+tbody+'>';
							}
							if(helper.keyExists(options, 'render.group.table.tfoot.build')){
								table += '<'+tfoot+' '+tfootClassAttr+' data-di-structure="tfoot">';
								table += options.render.group.table.tfoot.build(groupObj, scopedData);
								table += '</'+tfoot+'>';
							} else {
								table += '<'+tfoot+' '+tfootClassAttr+' data-di-structure="tfoot">'
								table += build.group.rows.tfoot(groupObj, groupKey);
								table += '</'+tfoot+'>';
							}
							table += '</'+tableTag+'>';	
						}
						return table;
					},
					rows: {
						tbody: function(groupObj, groupKey){
							var items = '';
							var rowsKeys = 'render.group.rows.tbody.';
							var itemCounter = 0;
							groupObj.items.forEach(function(itemObj, itemKey){
								//This logic is in where because I can't work out why its not working properly outside here - it just won't set the values - probably something stupid
								//Resets all limts to false and sets limit based off group settings 
								itemObj.settings.limit = false;
								if(itemKey >= groupObj.settings.items_limit && groupObj.settings.items_limit != -1){
									itemObj.settings.limit = true;
								}
								if(!itemObj.settings.limit){
									if(itemObj.settings.filter.filtered !== itemObj.settings.filter.results){
										var altClass = itemCounter % 2 ? 'even' : 'odd';
										var resultCounter = 0;
										itemObj.results.forEach(function(result){
											var scopedData = {result_counter: resultCounter, item: itemObj, item_counter: itemCounter, group: groupObj, options: options, config: config}
											if(!result.filter_flag){
												var rowAttrs = helper.getAttrs(options, rowsKeys + 'attrs', result, scopedData);
												var classAttr = helper.getClass(options, rowsKeys + 'class', result, scopedData, altClass);
												var tr = helper.getStructureTag('tr');
												var noResultLimit = itemObj.settings.result_limit == -1;
												var displayType = resultCounter > itemObj.settings.result_limit - 1 && !noResultLimit ? ' style="display: none" data-di-hidden' : '';
												if(helper.keyExists(options, rowsKeys + 'build')){
													items += '<'+tr+' ' + classAttr + displayType + rowAttrs + ' data-di-item-index="'+itemCounter+'" data-di-structure="tr">';
													items += options.render.group.rows.tbody.build(itemObj, scopedData);
													items += '</'+tr+'>';
												} else {
													items += '<'+tr+' ' + classAttr + displayType + rowAttrs + ' data-di-item-index="'+itemCounter+'" data-di-structure="tr">';
													items += build.group.columns(itemObj, itemCounter, options, resultCounter, result, groupObj, groupKey);
													items += '</'+tr+'>';
												}
												resultCounter ++;
											}
										});
										itemCounter ++;
									}
								}
							});
							items += build.group.rows.expand(groupObj, groupKey, itemCounter);
							items += build.group.rows.collapse(groupObj, groupKey, itemCounter);
							return items;
						},
						thead: {
							prehead: function(groupObj, groupKey){
								var prehead = '';					
								var tr = helper.getStructureTag('tr');
								var th = helper.getStructureTag('th');
								var scopedData = {group: groupObj, group_key: groupKey,data: data.formatted, options: options, config: config}
								var rowClassAttr = helper.getClass(options, 'render.group.rows.thead.prehead.class', groupObj, scopedData);
								//finds visible columns and stores (also stores keys in separate arr)
								var titles = helper.getTitles('prehead');
								//titles and there respective spans have been generated
								if(helper.keyExists(options, 'render.group.rows.thead.prehead.build')){
									prehead += '<'+tr+ ' ' + rowClassAttr + ' data-di-structure="tr">';
									prehead += options.render.group.rows.thead.prehead.build(groupObj, scopedData);
									prehead += '</'+tr+'>';
								} else {
									if(titles.length > 1){	
										prehead += '<'+tr+ ' ' + rowClassAttr + ' data-di-structure="tr">';
										titles.forEach(function(title, titleKey){
											var classAttr = '';
											if(typeof(title.class_name) == 'function'){
												classAttr = ' class="' + title.class_name(title.title, scopedData) + '"';
											} else if(typeof(title.class_name) == 'string'){
												classAttr = ' class="' + title.class_name + '"';
											}
											prehead += '<'+th+classAttr+' colspan="'+title.span+'" data-di-structure="th">'+title.title+'</'+th+'>';
										});
										prehead += '</'+tr+'>';
									}
								}
								return prehead;
							},
							column: function(groupObj, groupKey){
								var head = '';
								var scopedData = {group_key: groupKey, options: options, config: config}
								var tr = helper.getStructureTag('tr');
								if(helper.keyExists(options, 'render.group.rows.thead.column.build')){
									head += '<'+tr+ classAttr +' data-di-structure="tr">';
									head += options.render.group.rows.thead.column.build(groupObj, scopedData);
									head += '</'+tr+'>';
								} else {
									var classAttr = helper.getClass(options, 'render.rows.thead.column.class', groupObj, scopedData);
									head += '<'+tr+ classAttr +' data-di-structure="tr">';
									options.render.group.columns.forEach(function(column, columnKey){
										var columnSettings = options.render.group.columns[columnKey];
										var columnKeys = 'render.group.columns.' + columnKey + '.';
										var th = helper.getStructureTag('th');
										var sortClass = '', sortDataAttr = '';
										var scopedData = {options: options, group: groupObj, data: data.formatted, config: config};
										var sortDataAttrs = '';
										if(helper.keyExists(options, columnKeys + 'sort')){
											if(columnSettings.sort){
												var currentDirection = 'none';
												if(columnSettings.field == groupObj.settings.order.field){
													currentDirection = groupObj.settings.order.direction;
												}
												sortClass = 'sort';
												sortDataAttrs = ' data-di-sort-name="'+columnSettings.field+'" data-di-sort-direction="'+currentDirection+'"';
											} else {
												sortClass = '';
												sortDataAttrs = '';
											}
										}
										var columnTitle = '';
										if(helper.keyExists(options, columnKeys + 'head.title')){
											if(typeof(column.head.title) == 'function'){
												columnTitle = column.head.title(column, scopedData);
											} else if(typeof(column.head.title) == 'string'){
												columnTitle = column.head.title;
											}
										}
										var classAttr = helper.getClass(options, columnKeys + 'head.class', column, scopedData, sortClass);
										if(helper.getValue(options, columnKeys + 'visible', true)){
											head += '<'+th+ ' '+ classAttr + sortDataAttrs + '  data-di-structure="th">' + columnTitle + '</'+th+'>';
										}
									});	
									head += '</'+tr+'>';
								}
								return head;
							},
						},
						tfoot: function(groupObj, groupKey){
							var foot = '';					
							var tr = helper.getStructureTag('tr');
							var th = helper.getStructureTag('th');
							var scopedData = {group: groupObj, group_key: groupKey,data: data.formatted, options: options, config: config}
							var rowClassAttr = helper.getClass(options, 'render.group.rows.tfoot.class', groupObj, scopedData);
							if(helper.keyExists(options, 'render.group.rows.tfoot.build')){
								foot += '<'+tr+ rowClassAttr + ' data-di-structure="tr">';
								foot += options.render.group.rows.tfoot.build(groupObj, scopedData);
								foot += '</'+tr+'>';
							} else {
								//finds visible columns and stores (also stores keys in separate arr)
								var titles = helper.getTitles('foot');
								//titles and there respective spans have been generated
								if(titles.length > 1){	
									foot += '<'+tr+ rowClassAttr + ' data-di-structure="tr">';
									titles.forEach(function(title, titleKey){
										var classAttr = '';
										if(typeof(title.class_name) == 'function'){
											classAttr = ' class="' + title.class_name(title.title, scopedData) + '"';
										} else if(typeof(title.class_name) == 'string'){
											classAttr = ' class="' + title.class_name + '"';
										}
										foot += '<'+th+classAttr+' colspan="'+title.span+'" data-di-structure="th">'+title.title+'</'+th+'>';
									});
									foot += '</'+tr+'>';
								}
							}
							
							return foot;
						},
						expand: function(groupObj, groupKey, itemCounter){
							var expand = '';
							if(options.items.limit_expander){
								if(helper.keyExists(options, 'render.group.columns')){
									var columnLength = 0;
									options.render.group.columns.forEach(function(column){
										if(typeof(column.visible) == 'undefined' || column.visible){
											columnLength ++;
										}
									});
									if(groupObj.settings.items_limit != -1 && groupObj.settings.items_limit < groupObj.summary.items){
										var scopedData = {options: options, config: config}
										var classAttr = helper.getClass(options, 'render.group.content.limit_expander.class', groupObj, scopedData);
										var tr = helper.getStructureTag('tr');
										var td = helper.getStructureTag('td');
										var innerHTML = '';
										if(helper.keyExists(options, 'render.group.content.limit_expander')){
											innerHTML = options.render.group.content.limit_expander.build(groupObj, scopedData);
										} else {
											innerHTML = 'View All';
										}
										expand += 
											'<'+tr+' data-di-structure="tr">'+
												'<'+td + classAttr + ' colspan="'+columnLength+'" data-di-view-all="'+groupKey+'" data-di-structure="td">'+innerHTML+'</'+td+'>'+
											'</'+tr+'>'
									}
								}
							}
							return expand;
						},
						collapse: function(groupObj, groupKey, itemCounter){
							var collapse = '';
							if(options.items.limit_collapser){
								if(helper.keyExists(options, 'render.group.columns')){
									var columnLength = 0;
									options.render.group.columns.forEach(function(column){
										if(typeof(column.visible) == 'undefined' || column.visible){
											columnLength ++;
										}
									});
									if(groupObj.settings.items_limit != options.items.limit){
										var scopedData = {options: options, config: config}
										var classAttr = helper.getClass(options, 'render.group.content.limit_collapser.class', groupObj, scopedData);
										var tr = helper.getStructureTag('tr');
										var td = helper.getStructureTag('td');
										var innerHTML = '';
										if(helper.keyExists(options, 'render.group.content.limit_collapser')){
											innerHTML = options.render.group.content.limit_collapser.build(groupObj, scopedData);
										} else {
											innerHTML = 'View Fewer';
										}
										collapse += 
											'<'+tr+' data-di-structure="tr">'+
												'<'+td + classAttr + ' colspan="'+columnLength+'" data-di-view-fewer="'+groupKey+'" data-di-structure="td">'+innerHTML+'</'+td+'>'+
											'</'+tr+'>'
									}
								}
							}
							return collapse;
						}
					},
					columns: function(itemObj, itemKey, options, resultCounter, result, groupObj, groupKey){
						var columns = '';
						options.render.group.columns.forEach(function(column, columnKey){		
							var columnSetup = options.render.group.columns[columnKey],
								columnKeys = 'render.group.columns.' + columnKey + '.',
								td = helper.getStructureTag('td'),
								scopedData = {result: result, result_key: resultCounter, item: itemObj, item_key: itemKey, group_key: groupKey, group: groupObj, data: data.formatted, options: options, config: config},
								classAttr = helper.getClass(options, columnKeys + 'class', result[column.field], scopedData),
								colAttrs = helper.getAttrs(options, columnKeys + 'attrs', result[column.field], scopedData);
							if(helper.keyExists(options, columnKeys + 'build')){
								if(helper.getValue(options, columnKeys + 'visible', true)){
									columns += 
									'<'+td+ ' ' + classAttr + colAttrs +' data-di-structure="td">' + 
										columnSetup.build(result[column.field], scopedData) +
									'</'+td+'>';
								}
							} else {
								if(helper.getValue(options, columnKeys + 'visible', true)){
									columns += '<'+td+ ' ' + classAttr + colAttrs +' data-di-structure="td">' + result[column.field] + '</'+td+'>';
								}
							}
						});
						return columns
					},
					footer: function(groupObj, groupKey){
						var footer = '';
						var scopedData = {options: options, config: config}
						if(helper.keyExists(options, 'render.group.footer.build')){
							footer += '<div ' + helper.getClass(options, 'render.group.footer.class', data.formatted, scopedData) + '>';
							footer += options.render.group.footer.build(groupObj, groupKey);
							footer += '</div>';
						}
						return footer;
					},
				},
				footer: function(){
					var footer = '';
					var scopedData = {options: options, config: config}
					var classAttr = helper.getClass(options, 'render.footer.class', data.formatted, scopedData);
					if(helper.keyExists(options, 'render.footer.build')){
						footer += '<div '+ classAttr +'>';
						footer += options.render.footer.build(data.formatted);
						footer += '</div>';
					} else {
						footer +=
						'<div '+ classAttr +'>' +
							'Inventory data provided by <a href="https://www.oemsecrets.com">oemsecrets.com</a>' +
						'</div>';
					}
					return footer;
				}
			},
			//Render: Uses build methods to render on the DOM
			render = {
				body: function(){
					fetch.instanceNode().innerHTML = build.body();
				},
				table: function(index){
					var groupData = data.formatted.groups[index];
					fetch.instanceNode().querySelector('[data-di-table-index="'+index+'"]').innerHTML = build.group.table(groupData, index);
				},
				loading: function(){
					fetch.instanceNode().innerHTML = build.loading();
				},
				reloading: function(){
					fetch.instanceNode().innerHTML = build.reloading();
				}
			},
			//Events: Premade events that get added i.e. thead sorting
			events = {
				handlers: {
					items: {
						sort: function(groupIndex){
							if(typeof(groupIndex) == 'undefined'){
								fetch.instanceNode().querySelectorAll('.sort').forEach(function(target){
									target.onclick = function(){
										var groupNode = target.parentElement.parentElement.parentElement.parentElement;
									    var index = groupNode.dataset.diTableIndex;
										var newDirections = {none: 'asc', asc: 'desc', desc: 'asc'};
										if(options.results.expand_on_interaction){
											api.results.resultUngroup(index)
											api.items.limit(-1, index)
										}
										api.items.sort([target.dataset.diSortName, newDirections[target.dataset.diSortDirection]], index)
										api.render(index);
									}
								});
							} else {
								fetch.instanceNode().querySelectorAll('[data-di-group-index="'+groupIndex+'"] .sort').forEach(function(element){
									element.onclick = function(){
										var newDirections = {none: 'asc', asc: 'desc', desc: 'asc'};
										if(options.results.expand_on_interaction){
											api.results.resultUngroup(groupIndex)
											api.items.limit(-1, groupIndex)
										}
										api.items.sort([this.dataset.diSortName, newDirections[this.dataset.diSortDirection]], groupIndex)
										api.render(groupIndex);
									}
								});
							}
						},
						expand: {
							items: function(groupIndex){
								if(typeof(groupIndex) == 'undefined'){
									fetch.instanceNode().querySelectorAll('[data-di-view-all]').forEach(function(element){
										element.onclick = function(){
											var index = element.dataset.diViewAll;
											if(options.results.expand_on_interaction){
												api.results.resultUngroup(index);
											}
											api.items.limit(-1, parseInt(index));
											api.render(parseInt(index));
										}
									});
								} else {
									fetch.instanceNode().querySelectorAll('[data-di-view-all="'+groupIndex+'"]').forEach(function(element){
										element.onclick = function(){
											var index = element.dataset.diViewAll;
											if(options.results.expand_on_interaction){
												api.results.resultUngroup(index);
											}
											api.items.limit(-1, parseInt(index));
											api.render(parseInt(index));
										}
									})
								}
							},
						},
						collapse: {
							items: function(groupIndex){
								if(typeof(groupIndex) == 'undefined'){
									fetch.instanceNode().querySelectorAll('[data-di-view-fewer]').forEach(function(element){
										element.onclick = function(){
											var index = element.dataset.diViewFewer;
											api.items.limit(options.items.limit, parseInt(index));
											api.render(parseInt(index));
										}
									});
								} else {
									fetch.instanceNode().querySelectorAll('[data-di-view-fewer="'+groupIndex+'"]').forEach(function(element){
										element.onclick = function(){
											var index = element.dataset.diViewFewer;
											api.items.limit(options.items.limit, parseInt(index));
											api.render(parseInt(index));
										}
									})
								}
							},
						},
					}
				},
				add: function(groupIndex){
					events.handlers.items.sort(groupIndex);
					events.handlers.items.expand.items(groupIndex);
					events.handlers.items.collapse.items(groupIndex);
				}
			},
			//Main: When instance of DistributorInventory made initial construction is created from options
			main = {
				construct: function(){
					//Overwrites 'options' with 'setup' where specified
					fetch.setup();
					if(typeof(setup.search.term) !== 'undefined'){
						//Renders the loading element on the DOM
						render.loading();
						//Calls the PartSearchAPI and stores response in request
						fetch.data();
						//Runs the below methods on successful call of api
						request.success(function(response){
							//Use data.formatted to create the new object structure
							//Any additions to data outside of groups[] should created here and updated where appropriate
							data.format.initialise(response);
							//Updates options based on country that data has been pulled from
							fetch.userInfo();
							//Removes any data that needs to be permanently removed
							data.exclude.setup();
							//Any column data is removed from object nests and calculates which pricing to use on startup run
							//i.e. prices[currency][0]['unit_break'] becomes min_break
							/*This is done before main data format (format.group) to make finding uniques easier
							hence for any recalucations on this data post format (format.group) i.e. currency change use data.format.unpack.post*/
							data.format.appliedFilters();
							data.format.unpack.pre();
							//Finds uniques based for fields part_number, part_by_manufacturer, distributor_name, manufacturer and stores in data.formatted
							//improvement - could be combined with exlude.setup to save a loop of data
							data.instance.uniques.initial();
							//Data is placed into a group format based on 'options' preferences.
							//Fairly intensive process of lots of groups
							//For each 'unique' grouping i.e. part_by_manufacturer checks if data from unformatted data matches group
							//Structure for data is instance{} => groups[] => group{} => items[] => item{} => results[]
							//Groups is made up of objects containing summary, groups
							//At this stage each item has 1 result in results[] until result_group method (if run)
							//improvement - proccesses could be more optimized using grouping name as index?
							data.format.group(options.groups.field);
							//Part by manufacturer canonical data will be added if set i.e. a single datasheet / image for a part
							options.part_canons ? data.instance.canons.add() : '';
							//result_group method combines results with same distributor name and part name
							//Passing in an group index will set it for that group alone
							options.results.result_group ? data.results.resultGroup() : '';
							//Sorts the data using preferences from options
							//Sorting methods will reorganise the keys so anything that requires keys needs to be rerun on calling a sort method
							//Avoid using keys to count stuff and use a counter
							data.group.sort(options.groups.order);
							data.items.sort(options.items.order);
							data.items.manualOrder();
							data.results.sort(options.results.order);
							//Limits the number of items in a group
							//Doesn't remove data from 'data.formatted' - updates settings in each 'item' object
							data.items.limit();
							//Limits the number of groups
							//Doesn't remove data from 'data.formatted' - updates settings in each 'item' object
							//improvement - currently only filter ignores groups outside of limit
							data.group.limit();
							//Applies filters to data based on 'data.formatted.filters' (can be added / removed to via API)
							//Doesn't remove data from 'data.formatted' - updates settings in groups, items and results
							data.instance.filter();
							//callback before render has taken place
							options.callbacks.prerender(data.formatted, {options: options, config: config});
							//Uses build methods to render on DOM
							render.body();
							//Premade events like sorting in the thead and view more / fewer results
							events.add();
							//Will run user callback after render has taken place
							options.callbacks.render(data.formatted, {options: options, config: config});
						});
					}
				},
			},
			//Helper: General methods
			helper = {
				//Builds object from string until it doesn't exist
				//If the full object doesn't exist returns false
				//keyExists and findVal have been made because try catch isn't supported in IE
				keyExists: function(obj, string){
					var nest = string.split('.');
					var exists = true;
					nest.forEach(function(item, key){
						typeof(obj[item]) !== 'undefined' && exists ? obj = obj[item] : exists = false;
					});
				 	return exists;
				},
				//Builds object from string
				//Should only be run if helper.keyExists is true other wise will end in error
				//keyExists and findVal have been made because try catch isn't supported in IE
				findVal: function(obj, keyString){
					var section = obj;
					var nest = keyString.split('.');
					nest.forEach(function(item){
						section = section[item];
					});
					return section;
				},
				//Returns the value of a key in 'render'
				//Process done because value may or may not exist
				getValue: function(obj, keyString, fallback){
					if(helper.keyExists(obj, keyString)){
						var section = helper.findVal(setup, keyString);
						return section;
					}
					return fallback;
				},
				//Gets type of structure for all tags in table
				//Special case for the 'table' tag that defines everything inside of table tag i.e. th, tr etc
				getStructureTag: function(fallback){
					if(typeof(options.render.structure) == 'undefined' || options.render.structure == 'table'){
						return fallback
					}
					return options.render.structure;
				},
				//Retrusn an object with the footer / header layouts (with colspans)
				getTitles: function(location, callbackData){
					var visibleCols = [];
					var columns = [];
					options.render.group.columns.forEach(function(col, colKey){
						if(helper.getValue(options, 'render.group.columns.'+colKey+'.visible', true)){
							visibleCols.push(col);
						}
					});
					//finds the first visible key with a location.title property
					var populatedTitleKey = -1;
					for(var i = 0; i < visibleCols.length; i++){
						var col = visibleCols[i];
						if(typeof(col[location]) !== 'undefined'){
							if(typeof(col[location].title) !== 'undefined'){
								populatedTitleKey = i;
								i = visibleCols.length;
							}
						}
					}
					//Must contain minimum of one title
					if(populatedTitleKey !== -1){
						var columnIndex = 0;
						var prevTitle = visibleCols[populatedTitleKey][location].title;
						visibleCols.forEach(function(col, colKey){
							//if a column title doesn't exist create a blank one 
							if(typeof(col[location]) == 'undefined'){
								col[location] = {title: '', class: ''};
							} else {
								if(typeof(col[location].title) == 'undefined'){
									col[location].title = '';
								}
								if(typeof(col[location].class) == 'undefined'){
									col[location].class = '';
								}
							}
							//if columns is empty add this one
							if(columns.length == 0){
								columns.push({span: 1, title: col[location].title, class_name: col[location].class});
							//if previous title isn't the same as current create new column
							} else if(prevTitle !== col[location].title){
								columns.push({span: 1, title: col[location].title, class_name: col[location].class});
								columnIndex ++;
							//if key isn't the index of first populated title (as already added) and same then increment colspan
							} else if (prevTitle == col[location].title && colKey != populatedTitleKey){
								columns[columnIndex].span ++;
							}
							//update previous title
							prevTitle = col[location].title;
						});
					}
					return columns;
				},
				//Returns class names from 'render' and class attr string
				//Process done because value may or may not exist
				//Any default classes should be added using addtional
				//In 'render' is class is a function will run
				getClass: function(obj, keyString, data, scopedData, additionalClasses){
					additionalClasses = typeof(additionalClasses) !== 'undefined' ? ' ' + additionalClasses : '';
					if(helper.keyExists(obj, keyString)){
						var section = helper.findVal(setup, keyString);
						if(typeof(section) == 'function'){
							section = section(data, scopedData);
						}
						return ' class="' + section + additionalClasses +'"';
					} else if(!helper.keyExists(obj, keyString) && additionalClasses){
						return ' class="'+additionalClasses+'"';
					} else {
						return '';
					}
				},
				//Returns attribute key and values from on 'render'
				//Process done because value may or may not exist
				//The values data, dataKey and options should be relative to where its being called
				getAttrs: function(obj, keyString, data, scopedData){
					if(helper.keyExists(obj, keyString)){
						var section = helper.findVal(setup, keyString);
						var attrString = '';
						section.forEach(function(attr){
							if(typeof(attr.value) == 'function'){
								attrString += ' ' + attr.attr + '=' + '"' + attr.value(data, scopedData) + '"';
							} else {
								attrString += ' ' + attr.attr + '=' + '"' + attr.value + '"';
							}
						});
						return attrString;
					} else {
						return '';
					}
				},
				//Returns the price at the break passed in
				//improvement - think of way to optimise
				getBreakPrice: function(breakVal, prices){
					var unitBreakKey = -1;
					prices.forEach(function(breakInfo, key){
						if(breakInfo.unit_break <= breakVal){
							unitBreakKey = key;
						}
					});
					if(unitBreakKey != -1){
						return prices[unitBreakKey].unit_price;
					} else {
						return 0;
					}
				},
				//Modifies the options with preferences from setup
				replaceOptions: function(obj, keyString, location, key){
					helper.keyExists(obj, keyString) ? location[key] = helper.findVal(setup, keyString) : '';
				},
				//Removes special characters and makes uppercase from string passed in
				//todo - maybe not make uppercase?
				replaceNonAlpha(string){
					return string.replace(/[^a-z0-9]+/gi, '');
				},
				//Used for sorter to make values consistent i.e. float for int, uppercase for chars
				standardise: function(value){
					return !isNaN(parseFloat(value)) ? parseFloat(value) : value.toUpperCase();
				},
				//Sorts based on direction
				//to do - add in additional functionality i.e. exceptions and null / zero last
				sorter: function(direction, a, b){
					if(direction == 'asc'){
						if(a > b){ return 1; } else { return -1;}
						return 0;
					} else if(direction == 'desc') {
						if(a < b){ return 1; } else { return -1;}
						return 0;
					}
				},
			},
			//Api: Returned from running new instance. Interface between the 'user' and objects in DistributorInventory
			//Any method that re-uses 'data.formatted' shouldn't render the body again - down to 'user'
			//Any method that does a new PartSearchApi call should render the body again
			//When calling an API method the 'render' method will subsequently need to be called to render the changes
			//It the change only affects one group use render(index) with the group index to render that one group
			api = {
				//Event listeners
				on: {
					//Will only call once the PartSearchAPI call state is ready and successful
					success: function(callback){
						if(typeof(request.response.responseText) !== 'undefined'){
							request.response.addEventListener('readystatechange', function(){
								if(this.readyState == 4 && this.status == 200){
									callback(data.formatted, {options: options, config: config});
								}
							});
						}
					},
					//Can't think of a way to make this work but would be useful
					//Would mean everything wouldn't have to be in 'setup.callback'
					render: function(){
					},
				},
				//Filter methods
				filters: {
					//Take array of items that should be filtered and where to filter it
					//part_by_manufacturer, part_number, distributor_name, manufacturer, quantity_in_stock
					add: function(items, filterType){
						var filters = data.formatted.settings.filters[filterType];
						items.forEach(function(item){
							filters.push(item);
						});
						data.instance.filter();
					},
					//Take array of items that shouldn't be filtered and where to unfilter it
					//part_by_manufacturer, part_number, distributor_name, manufacturer, quantity_in_stock
					remove: function(items, filterType){
						var filters = data.formatted.settings.filters[filterType];
						items.forEach(function(item){
							filters.splice(filters.indexOf(item), 1);
						});
						data.instance.filter();
					},	
				},
				//Methods that don't require a new PartSearchApi call
				change: {
					//For changing the custom break quantity
					quantity: function(qty, index){
						if(typeof(index) == 'undefined'){
							options.breaks.custom = qty;
						}
						data.format.unpack.post(index, qty);
						data.group.summary.reprocess();
						//Running this function replaces the data in 'price_at_custom' in result
					},
					//Reorganise by different group type
					//part_by_manufacturer, part_number, distributor_name, manufacturer
					group: function(field){
						options.groups.field = field;
						data.format.group(options.groups.field);
						data.group.sort(options.groups.order);
						options.results.result_group ? data.results.resultGroup() : '';
						data.items.sort(options.items.order);
						data.items.manualOrder();
						data.results.sort(options.results.order);
						data.instance.filter();
						data.group.limit();
					},
					//Replaces the price_at_x, min_break_price, price_at_custom and sum_price
					currency: function(currency){
						options.currency = currency;
						data.format.unpack.post();
						data.group.summary.reprocess();
					},
				},
				//Methods that create new PartSearchApi call
				new: {
					//Calls new data from PartSearchApi and reorganises based on previous configurations
					term: function(term){
						options.search.term = term;
						render.loading();
						request.response = {};
						fetch.data();
						request.success(function(response){
							data.format.initialise(response);
							fetch.userInfo();
							data.exclude.setup();
							data.format.unpack.pre();
							data.instance.uniques.initial();
							options.part_canons ? data.instance.canons.add() : '';
							data.format.group(options.groups.field);					
							data.group.sort(options.groups.order);
							options.results.result_group ? data.results.resultGroup() : '';
							data.items.sort(options.items.order);
							data.items.manualOrder();
							data.results.sort(options.results.order);
							data.group.limit();
							data.instance.filter();
							options.callbacks.prerender(data.formatted, {options: options, config: config});
							render.body();
							events.add();
							options.callbacks.render(data.formatted, {options: options, config: config});
						});
					},
					//Calls new data from PartSearchApi and reorganises based on previous configurations
					//Difference - uses reloaded 
					country: function(countryCode){
						options.country = countryCode;
						render.reloading();
						request.response = {};
						fetch.data();
						request.success(function(response){
							data.format.initialise(response);
							fetch.userInfo();
							data.exclude.setup();
							data.format.unpack.pre();
							data.instance.uniques.initial();
							options.part_canons ? data.instance.canons.add() : '';
							data.format.group(options.groups.field);					
							data.group.sort(options.groups.order);
							options.results.result_group ? data.results.resultGroup() : '';
							data.items.sort(options.items.order);
							data.items.manualOrder();
							data.results.sort(options.results.order);
							data.group.limit();
							data.instance.filter();
							options.callbacks.prerender(data.formatted, {options: options, config: config});
							render.body();
							events.add();
							options.callbacks.render(data.formatted, {options: options, config: config});
						});
					},
				},
				//Methods for altering result data
				results: {
					sort: function(order){
						options.results.order = order;
						data.results.sort(order);
					},
					resultGroup: function(groupingType, index){
						if(typeof(index) == 'undefined'){
							options.results.result_group = groupingType;
							data.results.resultGroup();
							data.items.limit();
						} else {
							var currentLimit = data.formatted.groups[index].settings.items_limit;
							data.results.resultGroup(index);
							data.items.limit(index, currentLimit);
						}
					},
					resultUngroup: function(index){
						if(typeof(index) == 'undefined'){
							options.results.result_group = false;
							data.results.resultUngroup();
							data.items.limit();
						} else {
							var currentLimit = data.formatted.groups[index].settings.items_limit;
							data.results.resultUngroup(index);
							data.items.limit(index, currentLimit);
						}
					},
					limit: function(int, groupIndex, itemIndex){
						if(typeof(groupIndex) == 'undefined' && typeof(itemIndex) == 'undefined'){
							options.results.limit = int;
						}
						data.results.limit(groupIndex, itemIndex, int);
					}
				},
				//Methods for altering item data
				items: {
					sort: function(order, index){
						if(typeof(index) == 'undefined'){
							options.items.order = order;
						}
						data.items.sort(order, index);
					},
					limit: function(int, groupIndex){
						if(typeof(groupIndex) == 'undefined'){	
							options.items.limit = int;
						}
						data.items.limit(groupIndex, int);
					},
				},
				//Methods for altering group data
				groups: {
					sort: function(order){
						options.groups.order = order;
						data.group.sort(order);
						data.group.limit();
						data.instance.filter();
					},
					limit: function(int){
						options.groups.limit = int;
						data.group.limit();
						data.instance.uniques.rescan();
						data.instance.filter();
					},
					removeLimit: function(groupIndex){
						data.group.limit(groupIndex);
						data.instance.filter();
					},
				},
				//Toggle column visibile in column properties
				//This does not change DOM visibility - it re-renders contents
				columns: {
					visible: function(names, bool){
						options.render.group.columns.forEach(function(column){
							names.forEach(function(name){
								if(name == column.name){
									column.visible = bool;
								}
							})
						});
					},
				},
				//When calling an API method the 'render' method will subsequently need to be called to render the changes
				//It the change only affects one group use render(index) with the group index to render that one group
				//If groupIndex is undefined everything gets replaced (including event listeners) no other event listeners will be affected
				render: function(groupIndex){
					if(typeof(groupIndex) == 'undefined'){
						options.callbacks.prerender(data.formatted, {options: options, config: config});
						render.body();
						events.add();
						options.callbacks.render(data.formatted, {options: options, config: config});
					} else {
						options.callbacks.prerender(data.formatted, {options: options, config: config});
						render.table(groupIndex);
						events.add(groupIndex)
						options.callbacks.render(data.formatted, {options: options, config: config})
					}
				},
			}
			main.construct();
			return api;
		},
		//Tools Overview ->
			//Any tools that are useful for creating plugins
		tools: {
			//Modal Overview ->
				//When instance created / initialised 'main' is run with creates everything based on 'setup'
				//See 'main' for breakdown of processes
			//Modal objects ->
				//Dialog: Object used throughout modal from instance
				//Position: Methods relating to positioning on DOM
				//Dimensions: Methods relating to sizing on DOM
				//Build: Methods for generating the displayed content
				//Callbacks: Open / Close call back calls
				//Events: Any event handlers on creating modal
				//Main: Constructs instance of modal
				//Helper: Useful methods
			modal: function(setup){
				//Object used throughout modal from instance
				var dialog = {
				},
				settings = {
					position: {
						y: 'center',
						x: 'center',
					},
					dimensions: {
						height: 'initial',
						width: 600,
					}
				},
				initial = {
					setup: function(){
						if(typeof(setup.position) !== 'undefined'){
							if(typeof(setup.position.x) == 'string'){
								settings.position.x = setup.position.x;
							}
							if(typeof(setup.position.y) == 'string'){
								settings.position.y = setup.position.y;
							}
						}
						if(typeof(setup.dimensions) !== 'undefined'){
							if(typeof(setup.dimensions.height) != 'undefined'){
								settings.dimensions.height = setup.dimensions.height;
							}
							if(typeof(setup.dimensions.width) != 'undefined'){
								settings.dimensions.width = setup.dimensions.width;
							}
						}
					}
				},
				//Methods relating to positioning on DOM
				position = {
					x: {
						set: function(){
							switch(settings.position.x){
								case 'left': 
									dialog.modal.style.justifyContent = 'flex-start';
									if(setup.animate){
										dialog.content.classList.add(helper.getAnimation(setup.animate, settings.position.x));
									}
									break;
								case 'center': 
									dialog.modal.style.justifyContent = 'center';
									if(setup.animate){
										dialog.content.classList.add(helper.getAnimation(setup.animate, settings.position.x));
									}
									break;
								case 'right':  
									dialog.modal.style.justifyContent = 'flex-end';
									if(setup.animate){
										dialog.content.classList.add(helper.getAnimation(setup.animate, settings.position.x));
									}
									break;
							}
						}
					},
					y: {
						set: function(){
							switch(settings.position.y){
								case 'top': 
									dialog.modal.style.alignItems = 'flex-start';
									break;
								case 'center': 
									dialog.modal.style.alignItems = 'center';
									break;
								case 'bottom':  
									dialog.modal.style.alignItems = 'flex-end';
									break;
							}
						}
					}
				},
				//Methods relating to sizing on DOM
				dimensions = {
					set: function(){
						dialog.content.style.width = typeof(settings.dimensions.width) == 'string' ? settings.dimensions.width : settings.dimensions.width + 'px';
						dialog.content.style.height = typeof(settings.dimensions.height) == 'string' ? settings.dimensions.height : settings.dimensions.height + 'px';
					}
				},
				//Methods for generating the displayed content
				build = {
					content: function(){
						if(typeof(setup.content) == 'function'){
							if(typeof(setup.loading) == 'function'){
								dialog.content.innerHTML = setup.loading();
							}
							dialog.content.innerHTML = setup.content();
						}
					}
				},
				//Open / Close call back calls
				callbacks = {
					open: function(){
						if(typeof(setup.callbacks) == 'object'){
							if(typeof(setup.callbacks.open) == 'function'){
								setup.callbacks.open(dialog.content, dialog.trigger)
							}
						}
					},
					close: function(){
						if(typeof(setup.callbacks) == 'object'){
							if(typeof(setup.callbacks.close) == 'function'){
								setup.callbacks.close(dialog.content, dialog.trigger)
							}
						}
					},
				},
				//Any event handlers on creating modal
				events = {
					handlers: {
						close: function(modal){
							modal.onclick = function(event){
								var closeTarget = modal.querySelector('[data-di-modal-close]')
								if(event.target == modal || event.target == closeTarget){
									callbacks.close();
									dialog.modal.style.display = 'none';
									dialog.modal.style.alignItems = 'initial';
									dialog.modal.style.justifyContent = 'initial';
									dialog.content.style.width = 'initial';
									dialog.content.style.height = 'initial';
									dialog.content.classList.forEach(function(className, classKey){
										if(className.indexOf('di-animate') !== -1){
											dialog.content.classList.remove(className);
										}
									});
								}
							}
						}
					}
				},
				//Constructs instance of modal
				main = {
					construct: function(){
						//applies onclick handlers to all elements with the setup.trigger selector
						document.querySelectorAll(setup.trigger).forEach(function(trigger){
							trigger.onclick = function(){
								//should only be one modal but covers just in case
								initial.setup();
								document.querySelectorAll(setup.modal).forEach(function(modal){
									//sets variables used throughout modal from instance
									dialog.modal = modal;
									dialog.trigger = trigger;
									dialog.content = modal.querySelector('.di-modal-content');
									
									//renders the modal display
									dialog.modal.style.display = 'flex';
									position.y.set();
									position.x.set();
									dimensions.set();
									build.content();

									callbacks.open();
									//applies event listeners
									events.handlers.close(modal);
								});
							}
						});	
					}
				},
				//Useful methods
				helper = {
					getAnimation: function(animationType, position){
						switch(animationType){
							case 'slide':
								switch(position){
									case 'left':
										return 'di-animate-slide-in-left';
									case 'center': 
										return 'di-animate-slide-in-top';
									case 'right':
										return 'di-animate-slide-in-right';
								}
							case 'fade':
								return 'di-animate-fade-in';
						}
					
					}
				}
				main.construct();
			},
			//Tooltip Overview ->
				//When instance created / initialised 'main' is run with creates everything based on 'setup'
				//See 'main' for breakdown of processes
			//Tooltip objects ->
				//Tip: Object used throughout tooltip from instance
				//Position: Methods relating to positioning on DOM
				//Callbacks: Open / Close call back calls
				//Events: Any event handlers on creating tooltip
				//Animate: Any animation adding methods
				//Main: Constructs instance of tooltip
			tooltip: function(setup){
				//Object used throughout tooltip from instance
				var tip = {
				},
				settings = {
					width: 200,
					position: 'right',
					event: 'hover',
					theme: 'light',
				},
				initial = {
					setup: function(){
						if(typeof(setup.width) == 'number'){
							settings.width = setup.width;
						}
						var validPositions = ['top', 'bottom', 'left', 'right']
						if(validPositions.indexOf(setup.position) !== -1){
							settings.position = setup.position;
						}
						if(setup.event == 'click' || setup.event == 'hover'){
							settings.event = setup.event;
						}
						if(setup.theme == 'dark' || setup.theme == 'light'){
							settings.theme = setup.theme
						}
					}
				},
				//Methods relating to positioning on DOM
				position = {
					set: function(){
						var dimensions = {
							top_margin: parseFloat(getComputedStyle(tip.trigger).marginTop.match(/\d+/)[0]),
							right_margin: parseFloat(getComputedStyle(tip.trigger).marginRight.match(/\d+/)[0]),
							bottom_margin: parseFloat(getComputedStyle(tip.trigger).marginBottom.match(/\d+/)[0]),
							left_margin: parseFloat(getComputedStyle(tip.trigger).marginLeft.match(/\d+/)[0]),
							button_width: tip.trigger.offsetWidth,
							button_height: tip.trigger.offsetHeight,
						}
						var triggerPosition = helper.getPosition(tip.trigger);
						var space = {
							right: (window.innerWidth - dimensions.button_width - tip.content_width - triggerPosition.x + window.pageXOffset) > 0,
							left: (triggerPosition.x - tip.content_width - window.pageXOffset) > 0,
							top: (triggerPosition.y - tip.content_height - window.pageYOffset) > 0,
							bottom: (window.innerHeight - dimensions.button_height - tip.content_height - triggerPosition.y + window.pageYOffset) > 0,
						}
						switch(settings.position){
							case 'top':	
								if(space.top){
									position.place.top(dimensions, triggerPosition);
								} else {
									position.place.bottom(dimensions, triggerPosition);
								}
								break;
							case 'bottom':
								if(space.bottom){
									position.place.bottom(dimensions, triggerPosition); 
								} else {
									position.place.top(dimensions, triggerPosition); 
								}
								break;
							case 'right':
								if(space.right){	
									position.place.right(dimensions, triggerPosition);
								} else {
									position.place.left(dimensions, triggerPosition);
								}
								break;
							case 'left': 
								if(space.left){
									position.place.left(dimensions, triggerPosition);
								} else {
									position.place.right(dimensions, triggerPosition);
								}
								break;
						}
					},
					place: {
						top: function(dimensions, triggerPosition){
							tip.content.style.top = triggerPosition.y - tip.content_height - 5 + 'px';
							tip.content.style.left = triggerPosition.x - (tip.content_width / 2) + (dimensions.button_width / 2)  + 'px';
							tip.content.setAttribute('data-di-tooltip-position', 'top');
						},
						bottom: function(dimensions, triggerPosition){
							tip.content.style.top = triggerPosition.y + dimensions.button_height + 5 + 'px';
							tip.content.style.left = triggerPosition.x - (tip.content_width / 2) + (dimensions.button_width / 2)  + 'px';
							tip.content.setAttribute('data-di-tooltip-position', 'bottom');
						},
						right: function(dimensions, triggerPosition){
							tip.content.style.top = triggerPosition.y - (tip.content_height / 2) + (dimensions.button_height / 2) + 'px';
							tip.content.style.left = triggerPosition.x + dimensions.button_width + 5  + 'px';
							tip.content.setAttribute('data-di-tooltip-position', 'right');
						},
						left: function(dimensions, triggerPosition){
							tip.content.style.top = triggerPosition.y - (tip.content_height / 2) + (dimensions.button_height / 2) + 'px';
							tip.content.style.left = triggerPosition.x - tip.content_width - 5  + 'px';
							tip.content.setAttribute('data-di-tooltip-position', 'left');
						},
					}
				},
				//Open / Close call back calls
				callbacks = {
					open: function(){
						if(typeof(setup.callback) == 'object'){
							if(typeof(setup.callback.open) == 'function'){
								setup.callback.open(tip.content, tip.trigger)
							}
						}
					},
					close: function(){
						if(typeof(setup.callback) == 'object'){
							if(typeof(setup.callback.close) == 'function'){
								setup.callback.close(tip.content, tip.trigger)
							}
						}
					},
				},
				//Any animation adding methods
				events = {
					handlers: {
						close: function(eventType){
							var tooltipBackdrop = document.querySelector('body[data-di-tooltip-backdrop]');
							var closeHandler = function(event){
								//badly designed - but cant think of another solution
								//event listeners for body close are already added on trigger so would close in same event
								//this proccess ensures closes handlers are only called when clicked outside of trigger or content
								if(tip.trigger !== event.target){
									var childOfContent = false;
									//no internet explorer support for composedPath - prevents error
									var agent = window.navigator.userAgent;
									var msie = agent.indexOf('MSIE ');
    								if(msie == -1){
    									for(var nodeKey = 0; nodeKey < event.composedPath().length; nodeKey ++){
    										var node = event.composedPath()[nodeKey];
											if(typeof(node.dataset) !== 'undefined'){
												if(typeof(node.dataset.diTooltipId) !== 'undefined'){
													childOfContent = true;
													nodeKey = event.composedPath().length;
												}
											}	
    									}
									}
									//override childofcontent is has data attribute tooltip-close (no val required)
									if(typeof(event.target.dataset.diTooltipClose) !== 'undefined'){
										childOfContent = false;
									}
									if(!childOfContent){
										tip.content.remove();
										tip.body.removeAttribute('data-di-tooltip-backdrop');
										tooltipBackdrop.removeEventListener(eventType, closeHandler);
										callbacks.close();
									}
								}
							}
							tooltipBackdrop.addEventListener(eventType, closeHandler);
						},
					}
				},
				//Any animation adding methods
				animate = {
					set: function(){
						if(typeof(setup.animate) !== 'undefined'){
							if(setup.animate){
								if(setup.animate == 'fade'){
									tip.content.classList.add('di-animate-fade-in');
								} else if(setup.animate == 'slide'){
									tip.content.classList.add('di-animate-slide-in-bck-center');
								}
							}
						}
					}
				},
				//Constructs instance of tooltip
				//Currently also applies listeners to document - maybe separate
				main = {
					construct: function(){
						document.querySelectorAll(setup.trigger).forEach(function(trigger){
							initial.setup();
							if(settings.event == 'click'){
								trigger.onclick = function(){
									tip.body = document.querySelector('body');
									if(document.querySelectorAll('[data-di-tooltip-backdrop]').length == 0){
										if(trigger.parentElement.classList[0] !== 'di-tooltip-wrapper'){
											tip.id = Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);
											tip.wrapper = document.createElement('div');
											tip.content = document.createElement('div');
											tip.parent = trigger.parentElement;
											tip.trigger = trigger;
											tip.content.classList.add('di-tooltip-content', settings.theme);
											tip.content.style.width = settings.width + 'px';
											tip.content.innerHTML = setup.content(trigger, parent);
											tip.wrapper.classList.add('di-tooltip-wrapper');
											tip.content.setAttribute('data-di-tooltip-id', tip.id) ;
											//has to be appended before set dimensions (so can check sizing)
											document.body.append(tip.content)
											tip.wrapper.style.display = getComputedStyle(tip.trigger).display;
											tip.body.setAttribute('data-di-tooltip-backdrop', '');
											tip.content_height = tip.content.offsetHeight;
											tip.content_width = tip.content.offsetWidth;
											animate.set();
											position.set();
											callbacks.open();
											events.handlers.close('click');
										}
									}
								}
							} else if(settings.event == 'hover'){
								trigger.onmouseover = function(){
									tip.body = document.querySelector('body');
									if(document.querySelectorAll('[data-di-tooltip-backdrop]').length == 0){
										if(trigger.parentElement.classList[0] !== 'di-tooltip-wrapper'){
											tip.id = Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);
											tip.wrapper = document.createElement('div');
											tip.content = document.createElement('div');
											tip.parent = trigger.parentElement;
											tip.trigger = trigger;
											tip.content.classList.add('di-tooltip-content', settings.theme);
											tip.content.style.width = settings.width + 'px';
											tip.content.innerHTML = setup.content(trigger, parent);
											tip.wrapper.classList.add('di-tooltip-wrapper');
											tip.content.setAttribute('data-di-tooltip-id', tip.id) ;
											document.body.append(tip.content)
											tip.wrapper.style.display = getComputedStyle(tip.trigger).display;
											tip.body.setAttribute('data-di-tooltip-backdrop', '');
											tip.content_height = tip.content.offsetHeight;
											tip.content_width = tip.content.offsetWidth;
											animate.set();
											position.set();
											callbacks.open();
											events.handlers.close('mouseout');
										}
									}

								} 
							}
						});
					}
				},
				helper = {
					getPosition: function(element) {
						//moves through dom and adds x and y positions
					    var xPosition = 0;
					    var yPosition = 0;
					    while(element) {

					        xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
					        yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
					        element = element.offsetParent;
					    }
					    return { x: xPosition, y: yPosition };
					}
				}
				main.construct();
			},
		},
	}
}());